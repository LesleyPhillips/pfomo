<!-- HTML5 document type declaration -->
<!DOCTYPE html>
<!-- Root HTML element with English language attribute -->
<html lang="en">
<head>
    <!-- Character encoding set to UTF-8 for international character support -->
    <meta charset="UTF-8">
    <!-- Viewport meta tag for responsive design: sets initial scale, maximum scale, and disables user zoom -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Page title displayed in browser tab -->
    <title>pfomo.com</title>
    <!-- Embedded CSS styles for the terminal interface -->
    <style>
        /* Body style: monospace font, black background, green text (retro terminal look), no margin, touch-optimized */
        body { font-family: monospace; background-color: #000; color: #00ff00; padding: 10px; margin: 0; touch-action: manipulation; }
        /* Terminal container: full width, 90% viewport height, scrollable, wraps text, no tap highlight, breaks long words */
        #terminal { width: 100%; height: 90vh; overflow-y: auto; white-space: pre-wrap; -webkit-tap-highlight-color: transparent; word-wrap: break-word; }
        /* Links in terminal: pointer cursor, green color, underlined, clickable */
        #terminal a { cursor: pointer; color: #00ff00; text-decoration: underline; pointer-events: auto; }
        /* Input line container: flexbox layout for prompt and input field */
        #input-line { display: flex; }
        /* Input field: transparent background, green text, no border/outline, monospace font, full width */
        #input { background: transparent; color: #0f0; border: none; outline: none; font-family: monospace; width: 100%; }
        /* Hidden input field for mobile keyboard: positioned off-screen and invisible */
        #mobile-input { position: absolute; left: -9999px; opacity: 0; }
        /* Blinking horizontal cursor style: inline block with bottom border, green color, transparent background, animated blink */
        .cursor {
            display: inline-block;
            border-bottom: 2px solid #0f0;
            color: #0f0;
            background: transparent;
            line-height: 1;
            animation: blink 1s steps(1) infinite;
        }
        /* Keyframe animation for cursor blink: makes border transparent at 50% of animation cycle */
        @keyframes blink { 50% { border-color: transparent; } }
    </style>
</head>
<body>

    <!-- Main terminal display container where all output is rendered -->
    <div id="terminal"></div>
    <!-- Hidden input field for mobile keyboard support: disabled autocomplete, autocorrect, autocapitalize, and spellcheck -->
    <input type="text" id="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <script>
        // Version function: returns current version string with date/time stamp
        function version() {
            return "pfomo.com 20251208-1912";
        }

        // DOM element reference: the terminal display container
        const terminal = document.getElementById("terminal");
        // DOM element reference: hidden input field for mobile device keyboard
        const mobileInput = document.getElementById("mobile-input");
        // Array to store command history for up/down arrow navigation
        let commandHistory = [];
        // Current position in command history (-1 means not browsing history)
        let historyIndex = -1;
        // Global variable to store user's IP address (fetched asynchronously)
        let userip = "";
        // Boolean flag to detect if user is on a mobile device using user agent string
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        // Global variable for managing sound state
        let flgSound = false;


        //   ****   ****  ****   *****  *****  *   *
        //  *      *      *   *  *      *      **  *
        //   ***   *      ****   ***    ***    * * *
        //      *  *      *  *   *      *      *  **
        //  ****    ****  *   *  *****  *****  *   *

        // Screen buffer: 2D array simulating 30 lines of 80 characters each (classic terminal dimensions)
        let screenBuffer = Array(30).fill("").map(() => " ".repeat(80));
        // Cursor X position (column): 0-79
        let cursorX = 0;
        // Cursor Y position (row): 0-29
        let cursorY = 0;

        // Terminal API object: provides interface for commands to interact with the terminal
        // This object exposes methods for screen manipulation, rendering, and cursor control
        const Terminal = {
            screenBuffer,                                     // Direct access to the screen buffer array
            addInputLine: () => addInputLine(),               // Add a new input line with prompt
            clearScreen: () => clearScreen(),                 // Clear the screen and reset to welcome message
            getCursor: () => ({ x: cursorX, y: cursorY }),   // Get current cursor position as object
            getLineText: (y) => getLineText(y),              // Get text content of a specific line (excluding prompt)
            print: (text) => printToTerminal(text),          // Print text to terminal at current cursor position
            render: () => render(),                           // Re-render the terminal display
            scroll: () => scroll(),                           // Scroll the terminal up by one line
            setCursor: (x,y) => { cursorX = x; cursorY = y; }, // Set cursor position to specific coordinates
            setLineText: (y,text) => setLineText(y,text),    // Set text content of a specific line (starting at column 1)
            writeAt: (x,y,ch) => writeAt(x,y,ch)             // Write a single character at specific coordinates
        };

        // Flag to enable/disable keyboard input: true when prompt is active, false during command execution
        let typingEnabled = false;

        // Function: addInputLine - Prepares a new input line with prompt character
        function addInputLine() {
            // Boundary check: ensure cursor Y is within valid range (0-29)
            if (cursorY < 0) cursorY = 0;
            if (cursorY > 29) cursorY = 29;
            // Write prompt character '>' at the beginning of the current line (column 0)
            writeAt(0, cursorY, '>');
            // Clear the rest of the line after the prompt (columns 1-79)
            setLineText(cursorY, '');
            // Position cursor at column 1 (immediately after the prompt)
            cursorX = 1;
            // Enable keyboard input for user typing
            typingEnabled = true;
            // Re-render the terminal to show the prompt
            render();
        }

        // Function: clearScreen - Resets the terminal to initial state with welcome message
        function clearScreen() {
            // Reset screen buffer: create 30 new lines of 80 spaces each
            screenBuffer = Array(30).fill("").map(() => " ".repeat(80));
            // Define welcome message to display at top of screen
            const msg = "Lesley is near....";
            // Write message to line 0 and pad with spaces to fill full 80-character width for stable coordinates
            screenBuffer[0] = msg + " ".repeat(Math.max(0, 80 - msg.length));
            // Position cursor at column 0 of row 1 (row below welcome message)
            cursorX = 0;
            cursorY = 1;
            // Re-render the terminal to show cleared screen
            render();
        }

        // Function: getLineText - Retrieves text content from a specific line (excluding prompt character)
        // Parameter y: line number (0-29)
        // Returns: trimmed text from column 1 onwards (prompt at column 0 is excluded)
        function getLineText(y) {
            return (screenBuffer[y] || '').slice(1).replace(/\s+$/,'');
        }

        // Function: printToTerminal - Prints text to terminal at current cursor position with auto-wrap and scroll
        // Parameter text: string to print (default empty string)
        function printToTerminal(text = "") {
            // Iterate through each character in the text string
            for (let char of text) {
                // If character is newline, move to next line and reset column
                if (char === '\n') {
                    cursorY++;
                    cursorX = 0;
                } else {
                    // Write character at current cursor position
                    writeAt(cursorX, cursorY, char);
                    // Move cursor one column to the right
                    cursorX++;
                }
                // Auto-wrap: if cursor reaches end of line (column 80), wrap to next line
                if (cursorX >= 80) {
                    cursorX = 0;
                    cursorY++;
                }
                // Auto-scroll: if cursor reaches bottom of screen (line 30), scroll up
                if (cursorY >= 30) {
                    scroll();
                }
            }
            // Re-render terminal to display the newly printed text
            render();
        }

        // Function: scroll - Scrolls the terminal up by one line
        function scroll() {
            // Remove the top line from the buffer
            screenBuffer.shift();
            // Add a new blank line at the bottom (80 spaces)
            screenBuffer.push(" ".repeat(80));
            // Set cursor to last line (line 29)
            cursorY = 29;
        }

        // Function: setLineText - Sets text content for a specific line (starting at column 1, preserving column 0 for prompt)
        // Parameter y: line number (0-29)
        // Parameter text: text content to set
        function setLineText(y, text) {
            // Calculate maximum length (79 characters, since column 0 is reserved for prompt)
            const maxLen = Math.min(79, text.length);
            // Split the line into array of characters for manipulation
            let line = screenBuffer[y].split('');
            // Loop through columns 1-79 and set characters from text or spaces if text is shorter
            for (let i = 0; i < 79; i++) {
                line[i + 1] = i < text.length ? text[i] : ' ';
            }
            // Join character array back into string and update buffer
            screenBuffer[y] = line.join('');
        }

        // Function: render - Converts screen buffer to HTML and displays it with cursor and clickable URLs
        function render() {
            // Array to store HTML-formatted lines
            const lines = [];
            // Loop through each line in the screen buffer (30 lines)
            for (let y = 0; y < screenBuffer.length; y++) {
                const line = screenBuffer[y];
                // Check if this is the line where the cursor is currently located
                if (y === cursorY) {
                    // Array to build HTML for this line character by character
                    let chars = [];
                    // Loop through each character position (0-79) in the line
                    for (let x = 0; x < line.length; x++) {
                        let ch = line[x];
                        // Escape HTML special characters to prevent rendering issues
                        if (ch === '<') ch = '&lt;';
                        if (ch === '>') ch = '&gt;';
                        // Check if cursor is at this character position
                        if (x === cursorX) {
                            // Display character at cursor position with blinking underline cursor
                            // Keep underlying character visible so typing replaces it naturally
                            const displayChar = ch === ' ' ? '&nbsp;' : ch;
                            chars.push(`<span class="cursor">${displayChar}</span>`);
                        } else {
                            // Normal character: convert space to non-breaking space for proper display
                            chars.push(ch === ' ' ? '&nbsp;' : ch);
                        }
                    }
                    // Join all characters into a single HTML string for this line
                    lines.push(chars.join(''));
                } else {
                    // Non-cursor lines: process for URL detection and HTML escaping
                    let processedLine = line.trimEnd(); // Remove trailing spaces to clean up output
                    // Make URLs clickable FIRST (before HTML escaping) by marking them with temporary tags
                    // Regex matches http:// or https:// URLs (excluding spaces and angle brackets)
                    processedLine = processedLine.replace(
                        /(https?:\/\/[^\s<>]+)/g,
                        '<URL_MARKER>$1<\/URL_MARKER>'
                    );
                    // Escape HTML special characters (< and >) but protect our URL marker tags
                    processedLine = processedLine.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    // Restore URL markers and convert them to clickable anchor tags with green color
                    processedLine = processedLine.replace(
                        /&lt;URL_MARKER&gt;(https?:\/\/[^&\s<]+?)&lt;\/URL_MARKER&gt;/g,
                        '<a href="$1" target="_blank" style="color: #00ff00; text-decoration: underline;">$1</a>'
                    );
                    // Preserve spaces naturally via <pre> tag; no need for &nbsp; to keep anchors valid
                    lines.push(processedLine);
                }
            }
            // Set terminal innerHTML: wrap all lines in a <pre> tag with monospace styling and join with newlines
            terminal.innerHTML = `<pre style="font-family:monospace; margin:0; padding:0; background-color: #000; color: #0f0; overflow-wrap: break-word; white-space: pre-wrap;">${lines.join('\n')}</pre>`;
            // Auto-scroll terminal to bottom to show latest content
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Function: writeAt - Writes a single character at specific screen coordinates
        // Parameter x: column position (0-79)
        // Parameter y: row position (0-29)
        // Parameter char: single character to write
        function writeAt(x, y, char) {
            // Boundary check: return if coordinates are out of bounds
            if (y < 0 || y >= 30 || x < 0 || x >= 80) return;
            // Split line into character array for manipulation
            let line = screenBuffer[y].split('');
            // Set character at specified position
            line[x] = char;
            // Join array back into string and update buffer
            screenBuffer[y] = line.join('');
        }

        //   *   *  *****  *      ****   *****  ****    ****
        //   *   *  *      *      *   *  *      *   *  *    
        //   *****  ***    *      ****   ***    ****    *** 
        //   *   *  *      *      *      *      *  *       *
        //   *   *  *****  *****  *      *****  *   *  ****

        // Helper function: plays a system beep if sound is enabled
        function beep() {
            if (flgSound) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequency in Hz
                oscillator.type = 'sine';
                gainNode.gain.value = 0.3; // Volume
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1); // 100ms beep
            }
        }

        // Function: executeCommand - Parses and executes user-entered commands
        // Parameter command: full command string entered by user
        function executeCommand(command) {
            // Split command into parts (command + arguments) using whitespace as delimiter
            const cmdParts = command.trim().split(/\s+/);
            // Extract command keyword (first part) and convert to lowercase for case-insensitive matching
            const kw = cmdParts[0].toLowerCase();
            // Extract arguments (all parts after the command keyword)
            const args = cmdParts.slice(1);

            // Look up command function in the command registry
            const cmdFn = commandRegistry[kw];
            if (cmdFn) {
                // If command exists, try to execute it with args and Terminal API
                try {
                    cmdFn(args, Terminal);
                } catch (err) {
                    // If command throws an error, display error message
                    printToTerminal(`Error running command '${kw}': ${err.message}`);
                }
                return;
            }

            // If command not found in registry, display error message
            printToTerminal("UNKNOWN COMMAND");
        }

        // Function: handleKey - Global keyboard event handler for terminal input
        // Parameter event: keyboard event object
        function handleKey(event) {
            // Only process keys when typing is enabled (when prompt is active)
            if (!typingEnabled) return;

            // Ignore modifier-only key presses (Ctrl, Cmd) to prevent interference
            if (event.ctrlKey || event.metaKey) return;

            // Handle Enter key: execute command
            if (event.key === 'Enter') {
                event.preventDefault();
                // Save current cursor Y position (the line with the command)
                const inputLineY = cursorY;
                // Extract command text from the input line (excluding prompt character)
                const command = getLineText(inputLineY).trim();
                // Disable typing while command executes
                typingEnabled = false;

                // If command is not empty, process it
                if (command) {
                    // Add command to history for arrow key navigation
                    commandHistory.push(command);
                    // Reset history index to end of history
                    historyIndex = commandHistory.length;

                    // Move cursor to the line below input line so command output prints there
                    cursorY = inputLineY + 1;
                    cursorX = 0;
                    // Scroll if cursor goes off screen
                    if (cursorY >= 30) scroll();

                    // Execute the command (this may print output to terminal)
                    executeCommand(command);

                    // After command output, move to next line to prepare for new prompt
                    cursorY = cursorY + 1;
                    cursorX = 0;
                    // Scroll if cursor goes off screen
                    if (cursorY >= 30) scroll();
                } else {
                    // Empty command: just move to next line without executing anything
                    cursorY = inputLineY + 1;
                    cursorX = 0;
                    // Scroll if cursor goes off screen
                    if (cursorY >= 30) scroll();
                }

                // Add new input line with prompt for next command
                addInputLine();
                return;
            }

            // Handle Backspace key: delete character to left of cursor
            if (event.key === 'Backspace') {
                event.preventDefault();
                // Only allow backspace if cursor is beyond column 1 (can't delete prompt)
                if (cursorX > 1) {
                    // Move cursor left
                    cursorX--;
                    // Replace character with space (effectively deleting it)
                    writeAt(cursorX, cursorY, ' ');
                    // Re-render to show deletion
                    render();
                }
                return;
            }

            // Handle Arrow Up key: navigate backward through command history
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                // Exit if no history exists
                if (commandHistory.length === 0) return;
                // If not browsing history yet, start at most recent command
                if (historyIndex === -1) {
                    historyIndex = commandHistory.length - 1;
                } else if (historyIndex > 0) {
                    // Move backward in history
                    historyIndex--;
                }
                // Get command from history
                const entry = commandHistory[historyIndex] || '';
                // Replace current line text with historical command
                setLineText(cursorY, entry);
                // Position cursor at end of retrieved command
                cursorX = 1 + entry.length;
                // Re-render to display historical command
                render();
                return;
            }

            // Handle Arrow Down key: navigate forward through command history
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                // Exit if no history exists
                if (commandHistory.length === 0) return;
                // Exit if not currently browsing history
                if (historyIndex === -1) return;
                // Move forward in history if not at end
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    // Get next command from history
                    const entry = commandHistory[historyIndex] || '';
                    // Replace current line with command
                    setLineText(cursorY, entry);
                    // Position cursor at end of command
                    cursorX = 1 + entry.length;
                } else {
                    // If at end of history, clear the line and exit history browsing mode
                    historyIndex = -1;
                    setLineText(cursorY, '');
                    cursorX = 1;
                }
                // Re-render to display changes
                render();
                return;
            }

            // Handle printable characters: any single character key press (letters, numbers, symbols)
            if (event.key.length === 1) {
                event.preventDefault();
                // Write character at current cursor position
                writeAt(cursorX, cursorY, event.key);
                // Move cursor one position to the right
                cursorX++;
                // If cursor reaches end of line, wrap to next line
                if (cursorX >= 80) {
                    cursorX = 0;
                    cursorY++;
                }
                // If cursor reaches bottom of screen, scroll up
                if (cursorY >= 30) scroll();
                // Re-render to show new character
                render();
            }
        }

        // Attach global keyboard event handler to window object
        window.addEventListener('keydown', handleKey);

        // Mobile support: Click event handler to focus hidden input field
        terminal.addEventListener('click', () => {
            // On mobile devices, focus the hidden input to trigger keyboard
            if (isMobile && typingEnabled) {
                mobileInput.focus();
            }
        });

        // Mobile support: Touch event handler to focus hidden input field
        terminal.addEventListener('touchstart', (e) => {
            // When user taps terminal, focus hidden input to show keyboard
            if (typingEnabled) {
                mobileInput.focus();
            }
        }, { passive: true }); // Passive flag improves scroll performance

        // Mobile-specific input handling (only executed on mobile devices)
        if (isMobile) {
            // Input event handler: captures characters typed on mobile keyboard
            mobileInput.addEventListener('input', (e) => {
                // Only process if typing is enabled
                if (!typingEnabled) return;
                // Get the character that was just typed
                const char = e.data;
                // Only process single characters (not null or multi-char input)
                if (char && char.length === 1) {
                    // Write character at current cursor position
                    writeAt(cursorX, cursorY, char);
                    // Move cursor right
                    cursorX++;
                    // Wrap to next line if at end of line
                    if (cursorX >= 80) {
                        cursorX = 0;
                        cursorY++;
                    }
                    // Scroll if at bottom of screen
                    if (cursorY >= 30) scroll();
                    // Re-render to display character
                    render();
                }
                // Clear input field after processing to prepare for next character
                mobileInput.value = '';
            });

            // Keydown event handler for mobile: handles Enter and Backspace keys
            mobileInput.addEventListener('keydown', (e) => {
                // Handle Enter key on mobile
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Call main keyboard handler with synthetic Enter event
                    handleKey({ key: 'Enter', preventDefault: () => {} });
                    // Blur input briefly
                    mobileInput.blur();
                    // Re-focus after 100ms if typing still enabled
                    setTimeout(() => { if (typingEnabled) mobileInput.focus(); }, 100);
                } else if (e.key === 'Backspace') {
                    // Handle Backspace key on mobile
                    e.preventDefault();
                    // Call main keyboard handler with synthetic Backspace event
                    handleKey({ key: 'Backspace', preventDefault: () => {} });
                }
            });
        }

        // Async function: getUserIP - Fetches user's public IP address from external API
        async function getUserIP() {
            try {
                // Make request to ipify API for IP address in JSON format
                const response = await fetch("https://api64.ipify.org?format=json");
                // Parse JSON response
                const data = await response.json();
                // Return IP address string
                return data.ip;
            } catch (error) {
                // If fetch fails (network error, etc.), return "Unknown"
                return "Unknown";
            }
        }

        //     ****   ***   *   *  *   *    *    *   *  **** 
        //    *      *   *  ** **  ** **   * *   **  *  *   *
        //    *      *   *  * * *  * * *  *****  * * *  *   *
        //    *      *   *  *   *  *   *  *   *  *  **  *   *
        //     ****   ***   *   *  *   *  *   *  *   *  ****
        //
        //      *    *   *  ****
        //     * *   **  *  *   *
        //    *****  * * *  *   *
        //    *   *  *  **  *   *
        //    *   *  *   *  ****
        //
        //    *   *  *****  *      **** 
        //    *   *  *      *      *   *
        //    *****  ***    *      **** 
        //    *   *  *      *      *    
        //    *   *  *****  *****  *    

        // Command registry: object to store all available commands (maps command name to function)
        const commandRegistry = {};

        // Help map: object containing help text for each command (description and usage)
        const helpMap = {
            beep: { desc: 'Play a system beep sound (if sound is enabled)', usage: 'beep' },
            cls: { desc: 'Clear the screen and show welcome message', usage: 'cls' },
            drawcorners: { desc: 'Draw solid blocks in the four corners of the screen', usage: 'drawcorners' },
            drawrandomblocks: { desc: 'Draw N random block characters on the screen (default 100)', usage: 'drawrandomblocks [N]' },
            dir: { desc: 'Show a mock directory listing', usage: 'dir' },
            echo: { desc: 'Echo the arguments back', usage: 'echo <text>' },
            help: { desc: 'Show available commands. Use "help more" for details or "help [command]" for specific usage', usage: 'help [command|more]' },
            sound: { desc: 'Toggle sound on/off', usage: 'sound' },
            version: { desc: 'Show version string', usage: 'version' },
            whoami: { desc: 'Show browser / platform / IP info', usage: 'whoami' },
            whoislesley: { desc: 'Show Lesley contact links', usage: 'whoislesley' }
        };

        // Function: registerCommand - Registers a command in the command registry
        // Parameter name: command name (string)
        // Parameter fn: function to execute when command is called
        // Parameter help: optional help description for the command
        function registerCommand(name, fn, help) {
            // Add command function to registry (convert name to lowercase for case-insensitive lookup)
            commandRegistry[name.toLowerCase()] = fn;
            // If help text provided, add to help map
            if (help) helpMap[name.toLowerCase()] = { desc: help, usage: name };
        }

        // Register all built-in commands using the registry system
        registerCommand('beep', () => { cmdBeep(); }, 'Play a beep sound'); // Beep command
        registerCommand('cls', () => { cmdCls(); }); // Clear screen command
        registerCommand('drawcorners', () => { cmdDrawCorners(); }, 'Draw blocks in the four corners'); // Draw corners command
        registerCommand('drawrandomblocks', (args) => { cmdDrawRandomBlocks(args); }, 'Draw N random blocks'); // Draw random blocks command
        registerCommand('dir', () => { cmdDir(); }, 'Show mock directory'); // Directory listing command
        registerCommand('echo', (args) => { cmdEcho(args); }, 'Echo text'); // Echo command
        registerCommand('help', (args) => { cmdHelp(args); }); // Help command
        registerCommand('sound', () => { cmdSound(); }, 'Toggle sound'); // Sound toggle command
        registerCommand('version', () => { cmdVersion(); }, 'Show version'); // Version command
        registerCommand('whoami', () => { cmdWhoami(); }, 'Show client info'); // Who am I command
        registerCommand('whoislesley', () => { cmdWhoislesley(); }, 'Show Lesley links'); // Who is Lesley command

        // ========================================
        // COMMAND IMPLEMENTATIONS
        // ========================================

        // Command: beep - Plays a system beep sound
        function cmdBeep() {
            beep();
        }

        // Command: cls - Clears the screen and resets to welcome message
        // Command: cls - Clears the screen and resets to welcome message
        function cmdCls() {
            Terminal.clearScreen();
        }

        // Command: sound - Toggles the flgSound variable and displays the current state
        function cmdSound() {
            flgSound = !flgSound;
            printToTerminal(`Sound is now ${flgSound ? 'ON' : 'OFF'}`);
            if (flgSound) {
                beep(); // Play a test beep when sound is enabled
            }
        }

        // Command: dir - Displays a mock directory listing
        function cmdDir() {
            // Print fake directory contents as demonstration
            printToTerminal("[mock directory output]\nfile1.txt\nfile2.exe\nfolder1\n");
        }

        // Command: echo - Echoes back the arguments provided
        // Parameter args: array of arguments to echo
        function cmdEcho(args) {
            // Join arguments with spaces, or display default message if no args
            printToTerminal(args.join(' ') || 'Say what?');
        }

        // Command: help - Displays help information for commands
        // Parameter args: optional arguments (command name or 'more')
        function cmdHelp(args) {
            // Check if specific help requested
            if (args.length > 0) {
                // Get the target (command name or 'more')
                const target = args[0].toLowerCase();
                if (target === 'more') {
                    // help more - show detailed list with descriptions
                    printToTerminal('Available commands:\n');
                    // Get all command names and sort alphabetically
                    const keys = Object.keys(helpMap).sort();
                    // Print each command with its description
                    for (const k of keys) {
                        printToTerminal(`${k}: ${helpMap[k].desc}\n`);
                    }
                } else if (helpMap[target]) {
                    // help [command] - show specific command with usage
                    printToTerminal(`${target}: ${helpMap[target].desc} ${helpMap[target].usage}`);
                } else {
                    // Command not found in help map
                    printToTerminal(`No help available for '${target}'.`);
                }
            } else {
                // help - show comma-separated list of all commands
                const keys = Object.keys(helpMap).sort();
                printToTerminal(keys.join(', '));
                printToTerminal('\nAdditional help: help more');
            }
        }

        // Command: version - Displays the current version string
        function cmdVersion() {
            printToTerminal(version());
        }

        // Command: whoami - Displays browser, platform, and user information
        function cmdWhoami() {
            // Gather system information from browser APIs
            const info = {
                browser: navigator.userAgent,                                      // Full user agent string
                language: navigator.language || navigator.userLanguage,            // User's preferred language
                platform: navigator.platform,                                       // Operating system platform
                screenResolution: `${window.screen.width}x${window.screen.height}`, // Screen dimensions
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,        // User's timezone
                ip: userip || "Unknown",                                           // User's public IP (fetched at startup)
            };
            // Display info as formatted JSON with single-space indentation
            printToTerminal(JSON.stringify(info, null, ' '));
        }

        // Command: whoislesley - Displays Lesley's contact and social links
        function cmdWhoislesley() {
            printToTerminal('Blog: https://lesley-o0.blogspot.com\n');
            printToTerminal('LinkedIn: https://www.linkedin.com/in/lesley-phillips-ii');
        }

        // Command: drawcorners - Draws solid block characters in the four corners of the screen
        // Corners are at coordinates: (0,0), (79,0), (0,29), (79,29)
        function cmdDrawCorners() {
            writeAt(0, 0, '█');    // Top-left corner
            writeAt(79, 0, '█');   // Top-right corner
            writeAt(0, 29, '█');   // Bottom-left corner
            writeAt(79, 29, '█');  // Bottom-right corner
            render();              // Re-render to display blocks
        }

        // Command: drawrandomblocks - Draws N random block characters at random positions on screen
        // Parameter args: array where args[0] is the number of blocks (default 100)
        function cmdDrawRandomBlocks(args) {
            // Parse first argument as integer, or use NaN if invalid
            const n = args[0] ? parseInt(args[0],10) : NaN;
            // Use parsed number if valid and positive, otherwise default to 100
            const maxDots = Number.isFinite(n) && n>0 ? n : 100;
            // Loop to draw the specified number of blocks
            for (let i = 0; i < maxDots; i++) {
                // Generate random X coordinate (0-79)
                const x = Math.floor(Math.random() * 80);
                // Generate random Y coordinate (0-29)
                const y = Math.floor(Math.random() * 30);
                // Draw block character at random position
                writeAt(x, y, '█');
            }
            // Re-render to display all blocks
            render();
        }

        // ========================================
        // INITIALIZATION AND SETUP
        // ========================================

        // Async function: initializeGlobalVars - Initializes global variables at startup
        async function initializeGlobalVars() {
            // Fetch user's public IP address and store in global variable
            userip = await getUserIP();
        }

        // IIFE (Immediately Invoked Function Expression): Main initialization function
        // This async function runs automatically when the page loads
        (async () => {
            // Step 1: Initialize global variables (fetch user IP)
            await initializeGlobalVars();
            // Step 2: Clear screen and display welcome message
            clearScreen();
            // Step 3: Add blank line spacing after welcome message
            cursorY++;
            // Step 4: Display first input prompt and enable typing
            addInputLine();
        })(); // Execute immediately
    </script>

</body> <!-- End of body tag -->
</html> <!-- End of HTML document -->